ritmika ertekek kiirasa, set es map kiirasa, dom manipulacios dolgok, document.getelementsbytagname, document.getelementsbyclassname, quaryselector, quaryselectorAll, .innertext es .innerhtml es textcontent kulonbsege, append és appendchild kulonbsege, kerdes gyujtese ebben a kodban

# ismetles

## tortenelmi attekintes

1. ECMAScript - weboldal okositas, kismertekben fejlodott, nehez hasznalat, egyszeru funkciok bonyolultan, nem szerettek kevesen hasznaltak

#

2. konyvtarak megjelenese pl. JQuery - megjelenesuk lenyege: nehezsegek egyszerusitese, hatrany: renegeteg uj eltero szintaxisok, de ezzel is egyszeruseitettek (Bootstrap)

#

3. ES6 - dinamikus weboldalak letrehozasa, nagy frissites: moder nyelvi eszkozok, ujra gontolt valtozok, fuggvenyek; uj adatszerkezetek, fuggvenyek

#

4. Frontend keretrendszerek fejlesztese, megjelenese
   -> Frontend keretrendszer: komplex javascript konyvtar, egy adott
   problemara megoldas
   -> nem csak a htmlbe a cssbe is belenyul
   -> {{javascript}} tobbi html
   -> 2022ig mindennap jelent meg uj (uttoro: Google Angular, Facebook React(mar meta))
   -> angular csak typescript (az angular.js mas), react inkabb konyvtar mint keretrendszer

#

5. Backend keretrendszer (java, php, ? alapu adatbazis)
   -> Express.js : onnallo szoftverfuttatasra kepes
   -> Node.js : megszunik a bogeszotol fugges (Google Chrome motor)
   -> Vite : javascript alaku webszerver

#

6. FullStack: Backend + Frontend
   -> adatbazisok - relacios es nonrelacios

#

7. electron.js
   ->lightweight bongeszoben futo alkalmazasok jottek letre pl. visual studio code, discord, stb...
   ->viselkedese megegyzik az asztali es mobil alkalmazásokéval.

#

defer : kesleltetett betoltes

#

# javascript

    -> c alapu programozasi nyelv (script nyelv)
    -> gyengen tipusos - nem kell definialni a tipust pl int, string, double, stb... (c# erosen tipusos)
    -> interpreteles (ertelmezett) programozasi nyelv - ertelmezi a bongeszo
    -> forditott programozasi nyelv - letre jon belole egy futtathato allomany, exe file
    -> javascript opcionalis eleme - ;
    -> valtozok:
        var - nem hasznaljuk mert kepes vagy ugy hasznalni hogy nem definialtad meg
        let - altalanos valtozo, hasznaljuk
        const - allando, erteke nem valtozik
    -> tipusok:
        number - szam, egesz es valos szamokat tarol (kezdetben 53bit)
            NaN - not a number
            infinity
            - infinity
            BigInt - csak egesz szamokat tarol, 64 bit, sima szam error, jelolese n, pl 102n
        string - szoveg tarolasara, "+" jel osszevonja ha stringet osszefuzol szammal a szambol string lesz, indexelheto -> karaktert ad vissza, jsben a karakter is string, jelolese: " ", ' '
    -> template literal (szoszerinti sablon)
        jelolese: ` `
            van ${db} darab almam!
    -> boolean - logikai valtozo
        true or false ertekek
    -> undefined
        pl. let line
        line = 3
        (alatta hozod letre, nem fog mukodni!)
    -> null - hivatkozni valamire ami mar nincs
        pl. az APItol nem jott letre az adat
    -> Symbol(1) == Symbol(1) /nem egyezik a ketto mert minden szimbolum egyedi
        specialis string
        kulcsnak tokeletes, kulcsot dictionaryben, adatbazisban, stb..
        == C# - ertekeben egyenlo, tipusaban nem
        === js - ertekeben es tipusaban is egyenlo

#

ciklusok (literation) es elagazasok (selection) - vezerlesi szerkezetek
-> if : amely lehetővé teszi a döntéshozatalt a programban, és különböző kódblokkok végrehajtását a megadott feltételek alapján.
-> if else : ketiranyu elagazas
-> elseif : amikor több feltételt szeretnénk ellenőrizni egymás után
-> else : akkor fut le ha az if nem teljesul
-> while : addig fut amig a ciklus feltetel igaz, varhato lefutas = 0
-> do while : egyszer mindenkeppen lefut, eloszor lefut utana ertekeli ki
-> for : ciklusvaltozo, logikaiertek, lepesszam, addig fut amig igaz ha nem igaz akkor nem fut le
-> for..in : visszaadja egy gyujtemeny osszes indexet egyesevel
-> for..of : visszaadja egy gyujtemeny osszes tagjat egyesevel

#

logikai operatorok
-> + osszead
-> - kivon
-> \* szorzas
-> / osztas
-> // egesz osztas
-> % maradekos osztas
-> ++ novel eggyel
-> -- csokkent eggyel
-> == ertekeben egyenlo, tipusban nem
-> === ertekeben es tipusaban is egyenlo
-> != ertekben nem egyenlo
-> !== ertekben es tipusban nem egyenlo
-> ! tagadas
-> && logikai es
-> || logikai vagy
-> < nagyobb
-> > kisebb
-> <= nagyobb vagy egyenlo
-> >= kisebb vagy egyenlo

# logikai es igazsagtablaja

| &&  | 0   | 1   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 1   | 0   | 1   |

# logikai vagy igazsagtablaja

| or  | 0   | 1   |
| --- | --- | --- |
| 0   | 0   | 1   |
| 1   | 1   | 1   |

# logikai tagadas igazsagtablaja

| !   | 0   | 1   |
| --- | --- | --- |
|     | 1   | 0   |

#

# JavaScript array

Def: Egy olyan nem homogen adatszerkezet melynek merete dinamikusan valtozik

## Letrehozasa

1.  Literal:

- Jelolese: []

2.  Array konstruktor: \* Jelolese: new Array()

## Tomb fuggvenyek

1. `.push(<ertek>)`: a tomb vegere illeszti az uj elemet ezzel noveli a tomb meretet
2. `.length()`: visszaadja a tomb meretet
3. `array.unshift()`: elejére beszurja
4. `array.shift()`: kiveszi az elso elemet es vissza is adja
5. `array.pop()`: vegerol szed ki es vissza is adja
6. `array.splice(1, 0, "Feb")`: harom parameteres fuggveny, 1. melyik indexbol 2. hany erteket toroljon, 3. mit es mennyit
7. `array.ToString()`:
8. `array.Join(;)`: visszaadja a megadott szeparált karakterrel a tömböt
